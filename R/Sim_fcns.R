#' Sample Generation for Simulations
#'
#' @param n sample size.
#' @param d number of running variables.
#' @param C a smoothness parameter.
#' @param spec specifications to use.
#' @param sd_spec homoskedastic error if \code{sd_spec = "hom"};
#' heteroskedastic if \code{sd_spec = "het"}.
#' @param X_dist distribution of running variables
#' @param true_val the true parameter value; the default is 1.
#'
#' @return a list with \code{Yt}, \code{Yc}, \code{Xt}, \code{Xc}, \code{sigma_t},
#' and \code{sigma_c}.
#' @export
#'
#' @examples gen_obs(100, 1, 1/2, "Lin", "het", "equi")
gen_obs <- function(n, d, C, spec = c("Lin"), sd_spec = c("hom", "het"),
                    X_dist = c("equi"), true_val = 1){

  X_dist <- match.arg(X_dist)
  sd_spec <- match.arg(sd_spec)
  spec <- match.arg(spec)

  if(sd_spec == "hom"){

    sig = rep(1, n)

  }else if(sd_spec == "het"){

    sig <- stats::rnorm(n, 0, 1/sqrt(2))^2 + 1/2
  }

  if(d == 1){

    if(X_dist == "equi"){

      X <- matrix(seq(from = -1, to = 1, length.out = n), nrow = n, ncol = d)
      tind <- X < 0
    }

    Xt <- X[tind == 1, ,drop = F]
    Xc <- X[tind == 0, ,drop = F]
    sigma_t <- sig[tind == 1]
    sigma_c <- sig[tind == 0]

    if(spec == "Lin"){

      Yt = true_val + C * Xt + stats::rnorm(length(sigma_t), mean = 0, sd = sigma_t)
      Yc = C * Xc + stats::rnorm(length(sigma_c), mean = 0, sd = sigma_c)

    }
  }

  res <- list(Yt = Yt, Yc = Yc, Xt = Xt, Xc = Xc, sigma_t = sigma_t, sigma_c = sigma_c)
  return(res)
}

#' CI Result Generation
#'
#' @param obs_data a list object generated by \code{gen_obs} function.
#' @param method_sym a vector CI construction methods to be used; currently supports
#' \code{c("Ex", "rdr")}.
#' @param C_len the number of parameters to adapt to.
#' @param mon_ind the monotonicity index.
#' @param alpha the desired level of non-coverage probability.
#' @param trueC_min the value of the smoothness parameter for the smoothest true function
#' @param trueC_max the value of the smoothness parameter for the least smooth true function
#' @param true_val the true parameter value; default is 1.
#'
#' @return a vector of (coverage, CI_length) for each method - a vector of
#' length \code{len(method_sym) * 2}.
#' @export
#'
#' @examples obs_data <- gen_obs(100, 1, 1/2, "Lin", "het", "equi")
#' method_sym <- c("Ex", "rdr")
#' res_gen(obs_data, method_sym, 7, c(1), 0.05, 1/5, 1)
res_gen <- function(obs_data, method_sym, C_len, mon_ind, alpha,
                    trueC_min, trueC_max, true_val = 1){

  Xt <- obs_data$Xt
  Xc <- obs_data$Xc
  Yt <- obs_data$Yt
  Yc <- obs_data$Yc
  sigma_t <- obs_data$sigma_t
  sigma_c <- obs_data$sigma_c
  Y <- as.numeric(rbind(Yt, Yc))
  X <- as.numeric(rbind(Xt, Xc))

  m_len <- length(method_sym)

  res <- numeric(2 * m_len)

  for(i in 1:m_len){

    met <- method_sym[i]
    ind <- 2 * (i - 1) + 1

    if(met == "Ex"){

      C_min <- trueC_min
      C_max <- trueC_max
      Cvec <- seq(from = C_min, to = C_max, length.out = C_len)

      CI <- CI_adpt(Cvec, Xt, Xc, mon_ind, sigma_t, sigma_c, Yt, Yc, alpha)

    }else if(met == "rdr"){

      rdr_res <- rdrobust::rdrobust(Y, X)$ci
      CI <- c(-rdr_res[3, 2], -rdr_res[3, 1])

    }

    res[ind] <- as.numeric(CI[1] < true_val & CI[2] > true_val)
    res[ind + 1] <- CI[2] - CI[1]
  }

  return(res)

}


#' Dataframe Generation After Simulations
#'
#' @param res_all data matrix generated from simulations.
#' @param trueC a vector of true smoothness parameters used.
#' @param method_name a vector of names of CI construction methods used.
#'
#' @return a list containing coverage and length results stored as \code{data.frame}.
#' @export
#'
#' @examples trueC <- c(0.1, 0.2)
#' method_name <- c("a", "b")
#' m_len <- length(method_name)
#' trueC_len <- length(trueC)
#' nIters <- 50
#' rowlen <- m_len * trueC_len * 2
#' res_all <- matrix(stats::rnorm(rowlen * nIters), nrow = rowlen, ncol = nIters)
#' res_form(res_all, trueC, method_name)
res_form <- function(res_all, trueC, method_name){

  m_len <- length(method_name)
  trueC_len <- length(trueC)

  resMean <- rowMeans(res_all)
  col_C <- rep(trueC, each = m_len)
  col_met <- rep(method_name, trueC_len)
  col_cov <- resMean[c(TRUE, FALSE)]
  col_len <- resMean[c(FALSE, TRUE)]

  cov_data <- data.frame(C = col_C, cov_prob = col_cov, method = col_met)
  len_data <- data.frame(C = col_C, cov_prob = col_len, method = col_met)

  res <- list(cov_data = cov_data, len_data = len_data)
}
