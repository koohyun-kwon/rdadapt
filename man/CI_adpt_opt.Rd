% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CI_intsec_RD.R
\name{CI_adpt_opt}
\alias{CI_adpt_opt}
\title{Adaptive Confidence Interval with Optimal Lipschitz Coefficients}
\usage{
CI_adpt_opt(
  C_l,
  C_u,
  C,
  Xt,
  Xc,
  mon_ind,
  Yt,
  Yc,
  alpha,
  se.method = c("nn", "supplied", "nn.test"),
  sigma_t,
  sigma_c,
  sigma_t.init,
  sigma_c.init,
  J,
  se.init = c("Silverman", "supplied", "supp.sep", "S.test"),
  t.dir = c("left", "right"),
  n_grid = 10,
  gain_tol = 0.05,
  ratio = TRUE,
  p = Inf,
  n_sim = 10^5,
  delta_init = 1.96,
  N = 3
)
}
\arguments{
\item{C_l}{lower end of the adaptation range.}

\item{C_u}{upper end of the adaptation range.}

\item{C}{the Lipschitz coefficient for the function space we consider.}

\item{Xt}{\eqn{n_t} by \eqn{k} design matrix for the treated units.}

\item{Xc}{\eqn{n_c} by \eqn{k} design matrix for the control units.}

\item{mon_ind}{index number for monotone variables.}

\item{Yt}{outcome value for the treated group observations.}

\item{Yc}{outcome value for the control group observations.}

\item{alpha}{desired upper quantile value.}

\item{se.method}{standard deviation estimation methods.}

\item{sigma_t}{standard deviation of the error term for the treated units
(either length 1 or \eqn{n_t}).}

\item{sigma_c}{standard deviation of the error term for the control units
(either length 1 or \eqn{n_c}).}

\item{sigma_t.init}{supplied first-stage variance for treated observations.}

\item{sigma_c.init}{supplied first-stage variance for control observations.}

\item{J}{a positive integer; if specified,
the sequence of Lipschitz coefficients is set to be J equidistant grids
in \code{(C_l, C_u)}, without the optimal choice procedure.}

\item{se.init}{the standard deviation estimation method for choosing an optimal estimator.}

\item{t.dir}{treatment direction; \code{t.dir = "left"} if \eqn{x < 0} is treated.
Otherwise, \code{t.dir = "right"}. This should specified only for one-dimensional cases.}

\item{n_grid}{number of grid points to evaluate the lengths.}

\item{gain_tol}{stopping criterion when finding the optimal J.}

\item{ratio}{the ratio measure is used if \code{TRUE};
otherwise, the difference measure is used.}

\item{p}{the order of \eqn{l_1}-norm; the default is \code{Inf}.}

\item{n_sim}{number of simulated observations to calculate the
expectation of the minimum of multivariate normal random variables;
the default is \code{n_sim = 10^5}.}

\item{delta_init}{the value of \eqn{\delta} to be used in simulating the quantile;
theoretically, its value does not matter asymptotically. Its default value is 1.96.}

\item{N}{number of nearest neighbors to match when doing the variance estimation.}
}
\description{
Constructs an adaptive lower CI after choosing the optimal sequence of
Lipschitz coefficients.
}
\details{
This function also supports variance estimation.
}
\examples{
n <- 500
d <- 2
X <- matrix(rnorm(n * d), nrow = n, ncol = d)
tind <- X[, 1] < 0 & X[, 2] < 0
Xt <- X[tind == 1, ,drop = FALSE]
Xc <- X[tind == 0, ,drop = FALSE]
mon_ind <- c(1, 2)
sigma <- rnorm(n)^2 + 1
sigma_t <- sigma[tind == 1]
sigma_c <- sigma[tind == 0]
Yt = 1 + rnorm(length(sigma_t), mean = 0, sd = sigma_t)
Yc = rnorm(length(sigma_c), mean = 0, sd = sigma_c)
CI_adpt_opt(0.1, 1, 2, Xt, Xc, mon_ind, Yt, Yc, 0.05, "supplied", sigma_t, sigma_c, J = 5,
se.init = "supplied")
d <- 1
X <- rnorm(n)
tind <- X < 0
Xt <- X[tind == 1]
Xc <- X[tind == 0]
mon_ind <- 1
sigma <- rep(1, n)
sigma_t <- sigma[tind == 1]
sigma_c <- sigma[tind == 0]
Yt <- 1 + rnorm(length(sigma_t), mean = 0, sd = sigma_t)
Yc <- rnorm(length(sigma_c), mean = 0, sd = sigma_c)
CI_adpt_opt(0.1, 1, 2, Xt, Xc, mon_ind, Yt, Yc, 0.05, "nn", se.init = "Silverman",
t.dir = "left")
CI_adpt_opt(1, 1, 2, Xt, Xc, mon_ind, Yt, Yc, 0.05, "nn", se.init = "Silverman",
t.dir = "left")
}
